"""
漏洞预测任务适配器
处理漏洞预测和检测任务的模型加载和数据处理
"""

import os
import sys
import logging
from typing import Dict, Any, Optional, List

# 添加项目路径
BASE_DIR = os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(__file__)))))
sys.path.append(BASE_DIR)
sys.path.append(os.path.join(BASE_DIR, 'roberta', 'vulnerability-prediction', 'code'))

from app.attacks.task_adapters.base_adapter import TaskAdapter

logger = logging.getLogger(__name__)


class VulnerabilityAdapter(TaskAdapter):
    """
    漏洞预测任务适配器

    处理漏洞预测和检测任务，使用分类模型判断代码是否存在安全漏洞。
    """

    def __init__(self, task_type: str = 'vulnerability-prediction', model_name: str = 'codebert'):
        super().__init__(task_type, model_name)

    def get_model_class(self):
        """
        返回漏洞预测任务使用的模型类

        Returns:
            Model 类
        """
        try:
            from model import Model
            return Model
        except ImportError:
            logger.error("无法导入漏洞预测模型类，请检查路径配置")
            raise

    def get_config_params(self) -> Dict[str, Any]:
        """
        返回漏洞预测任务的配置参数

        Returns:
            配置参数字典
        """
        return {
            'num_labels': 2,  # 二分类：是否存在漏洞
            'task_type': 'classification',
            'max_length': 512,
        }

    def preprocess_input(self, code_data: Dict[str, str]):
        """
        预处理漏洞预测输入数据

        Args:
            code_data: 包含code1和code2的字典（漏洞预测通常只需要一段代码）

        Returns:
            预处理后的数据
        """
        from utils import get_code_tokens

        # 漏洞预测任务通常只分析一段代码
        code = code_data.get('code1', code_data.get('code', ''))

        # 分词处理
        code_tokens = get_code_tokens(code) if code else []

        return {
            'code_tokens': code_tokens,
            'original_code': code
        }

    def postprocess_output(self, model_output) -> Dict[str, Any]:
        """
        后处理漏洞预测模型输出

        Args:
            model_output: 模型输出元组 (logits, predictions)

        Returns:
            处理后的结果字典
        """
        logits, predictions = model_output

        # 获取预测结果
        predicted_label = predictions[0] if len(predictions) > 0 else 0
        confidence = float(max(logits[0])) if len(logits) > 0 and len(logits[0]) > 0 else 0.0

        return {
            'predicted_label': predicted_label,
            'confidence': confidence,
            'logits': logits.tolist() if hasattr(logits, 'tolist') else logits,
            'has_vulnerability': predicted_label == 1,  # 1表示有漏洞，0表示安全
            'vulnerability_score': confidence
        }

    def get_supported_models(self) -> List[str]:
        """返回支持的模型列表"""
        return ['codebert', 'codet5', 'codegpt', 'graphcodebert', 'plbart']

    def validate_input(self, code_data: Dict[str, str]) -> bool:
        """验证输入数据"""
        # 漏洞预测可以接受code1/code2或单独的code字段
        code = code_data.get('code1', code_data.get('code', ''))
        return isinstance(code, str) and len(code.strip()) > 0
